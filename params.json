{"name":"Unity Initialisation Order","tagline":"","body":"# Purpose of Document\r\nThroughout Repair's (and MV2's) development we haven't had a design need to construct GameObjects at runtime, however recently this has come up as a requirement and has forced us to question how and when construction logic should occur. The default assumption of 'put everything in Start()' hides the complexities inherent with Unity's own construction and update order.\r\n\r\nThis document tries to bring Unity's construction order, and the reasoning behind Repair's approach to use construction / initialisation messages (Awake, OnEnable, Start) and their paired destructors (OnDisable, OnDestroy)\r\n\r\n# Unity Initialisation 101\r\nhttps://docs.unity3d.com/Manual/ExecutionOrder.html\r\n\r\n### CONSTRUCTION / INITALISATION\r\n**Awake**() -> Called once for the lifetime of an object, called on the first frame the object is enabled for, whether it is constructed due to being within a scene, or due to code instantiation.\r\n\r\n**OnEnable**() -> Called whenever a component is set to an enabled state from a disabled state, with respect to **Awake**() it is called immediately after **Awake**(), unlike **Awake**() it will be called again if the object gets disabled and enabled again.\r\n\r\n**Start**() -> Like Awake, called once for the lifetime of an object, guaranteed to be called before the objects Update() is called\r\n\r\n### DESTRUCTION\r\n**OnDisable**() -> Called immediately before OnDestroy()\r\n\r\n**OnDestroy**() -> Final moment before c# object destruction\r\n\r\n# Rules of Thumb\r\n\r\n## When To Use Awake()\r\nAwake is called once for the lifetime of a given object. As such it makes sense to put code into **Awake**() which could not be affected by other runtime events and should never change:\r\n* References to external objects that will never change over the lifetime of the object\r\n* Construction of internal objects and internal references that will never change over the lifetime of the object\r\n* Setup of internal references for external use, such as a static instance field, e.g. the pattern:\r\n\r\n`\tprotected virtual void Awake()\r\n\t{\r\n\t\t_instance = this;\r\n\t}`\r\n\r\n## When To Use OnEnable()\r\n**OnEnable**() is called immediately after **Awake**() if the GameObject or Component is already set activeInHierarchy\r\n\r\nAdditionally:\r\n\r\n**OnEnable**() is called whenever a Component becomes enabled, e.g. ticking the on/off box in the inspector, or the GameObject on/off box in the inspector.\r\n\r\n**OnEnable**() is also called when calling **GameObject.SetActive**(true); or **Component.enabled = true**\r\n\r\nIf the component is constructed via instantiation (GameObject.Instantiate(PREFAB)) and the prefab is set as enabled, then **Awake**() and **OnEnable**() are called by the Instantiate function, one after one another. (An example of this can be found later in this document). \r\n\r\n**OnEnable**() should be used for most cases of instantiation and construction logic for any Component. In particular, anything that you may put in an object pool and enable at a later (runtime) point in execution. Or objects that you intend to disable and enable throughout runtime but know that their state needs to be reinitialised each time.\r\n\r\n**In General _OnEnable_() can be thought of as a traditional constructor, with **OnDisable**() as a traditional destructor (and can contain both references initialisation and logic initialisation depending on the use case)**\r\n\r\n* References to scene objects that can only be known at runtime (such as 'get me a list of all currently alive birds')\r\n* Interfacing with objects that may only exist after a scene loads\r\n* Performing construction logic that may involve changing the state of itself or other objects\r\n\r\n## When To Use Start()\r\nStart is called once for the lifetime of an object, but is *not* going to be called when an object is instantiated in an **Update**() at runtime. Therefore you cannot guarantee an object **Start**() has been called by the time you wish to use it. As such, it should not run code that affects initialisation.\r\n\r\n* Verifying a reference's validity and potentially performing error state handling\r\n* Kick off a logic event for the first frame of the game, e.g. UIService::FadeInGameUI();\r\n* Start a looping animation or first frame kick-off animation\r\n\r\n# Exceptions\r\nAs with all game development, these suggestions are never hard and fast but should cover common scenarios without too much thinking. It is important to ensure that you understand the construction order and why you are doing it if you break these guidelines. You should leave a code comment explaining these exceptions when they occur.\r\n\r\n## Example\r\n### Instantiating a GameObject during runtime that can be used immediately.\r\nWhen you instantiate a GameObject in **Update**():\r\n\r\n**Awake**() and **OnEnable**() will be called but crucially **Start**() will not be called until the following frame. \r\n\r\nIf you need to use the object on the same frame you instantiate it, it *must* be in a good state immediately after **Awake**() and **OnEnable**() have run, therefore all initialisation code must be done in either **Awake**() or **OnEnable**(), and not in **Start**().\r\n\r\nTo illustrate this:\r\n\r\n    \r\n    Factory::Update()\r\n    {\r\n        if (Time.frameCount == 0)\r\n        {\r\n            GameObject screwPrefab = Resources.Load<GameObject>(SCREW_PREFAB_LOCATION);\r\n            GameObject screw = GameObject.Instantiate(screwPrefab);\r\n            screw.PerformFunction();\r\n        }\r\n    }\r\n    \r\n\r\nExecution order over the first 2 frames\r\n\r\n**Frame 0:**\r\n\r\n\tINITIALISATION\r\n\t    Factory::Awake();\r\n\t    Factory::OnEnable();\r\n\t\r\n\tSTART\r\n\t    Factory::Start();\r\n\t\r\n\tUPDATE\r\n\t    Factory::Update() -> Instantiate Screw();\r\n\t    \r\n\t    // Begin initialisation for Screw\r\n\t    \r\n\t    Screw::Awake();\r\n\t    Screw::OnEnable();\r\n\t    \r\n\t    // End initialisation for Screw\r\n\t    // Screw is now ready to use!\r\n\t\r\n\tLATE UPDATE\r\n\t    Factory::LateUpdate();\r\n\r\n**Frame 1:**\r\n\r\n\tINITIALISATION\r\n\t     -\r\n\tSTART\r\n\t    Screw::Start();\r\n\t    // No real initialisation code should be done in Start()\r\n\t    // because it was already done in the previous frame\r\n\t\r\n\tUPDATE\r\n\t    Factory::Update();\r\n\t    Screw::Update();\r\n\t\r\n\tLATE UPDATE\r\n\t    Factory::LateUpdate();\r\n\t    Screw::LateUpdate();\r\n","note":"Don't delete this file! It's used internally to help with page regeneration."}